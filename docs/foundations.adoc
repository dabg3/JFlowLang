= Fluent API as Formal Language
:stem: latexmath

Definition of a Fluent API for workflow generation.

== Introduction

The purpose is to define a Java type which allows valid call chains only,
invalid sequences must not compile. 

.Example of a valid call chain 
[source, java]
----
WorkflowBuilder
    .boostrap()
    .chain()
    .chain()
    /* ...more chain() */
    .loopWhile()
        .chain()
        /* ...more chain() */
    .loopEnd()
    .chain()
    .build()
----

.Examples of invalid chains
[source, java]
----
WorkflowBuilder
    .boostrap()
    .chain()
    .loopWhile() 
        //a loop cannot be empty
    .loopEnd() 
    .build()

WorkflowBuilder
    .boostrap()
    .chain()
    .loopWhile()
    .chain()
    .build() // missing loop endmark loopEnd() 

WorkflowBuilder
    .bootstrap()
    .build() //empty workflow is not allowed
----

A subset of the actual language is choosen to simplify implementation,
follows a brief explanation of each method, parameters are excluded since 
the focus is on getting right the call chain.

bootstrap():: provide a context shared by all activities in the workflow.
chain():: add an activity to the workflow (unit of work)
loopWhile():: repeat a sequence of activity until condition is false
loopEnd():: mark the end of a loop
build():: instantiate the worflow

== Applying Theory

Fluent APIs are closely related to the theory of formal languages and automata, 
this work is based on the paper https://doi.org/10.4230/LIPIcs.ECOOP.2016.10[
Formal Language Recognition with the Java Type Checker].

[quote]
If the DSL specification is that of a deterministic context-free language, 
then a fluent API exists for the language...

DCFLs are generated by deterministic context-free grammars (DCFGs) which are
a subset of CFGs defined in terms of _reductions_ with certain properties.

A DCFG-generated string stem:[s \in \Sigma^*] can be _reduced_ to the start
variable stem:[S] by a series of _reduction steps_. 
If stem:[s] _is reducible to_ stem:[S], written 
stem:[s \overset{*}{\rightarrowtail} S], then exists only one sequence of 
leftmost reductions 
stem:[s = u_1 \rightarrowtail u_2 \rightarrowtail ... \rightarrowtail u_n = S]
such that:

* stem:[u_i = xhy \rightarrowtail xTy = u_{i+1}], suppose rule 
stem:[T \rightarrow h] is applied in reverse
* stem:[h] is unique in every _valid string_ stem:[xhz] where stem:[z \in \Sigma^*], 
so stem:[h] is a *forced handle*

[sidebar]
====
A *valid string* is a string that appears in a leftmost reduction. +
i.e. stem:[u_i] above is a valid string

An *handle* in a valid string is the reducing string together with its 
reduction rule.
====

=== Language Grammar

Let's try to define a DCFG for the Fluent API

[source]
====
S -> C build | C W build | W build

C -> C C | chain

W -> W C | W W | loopWhile C loopEnd | loopWhile C W loopEnd
====

.Reductions, handle is underlined
[source]
====
{empty} [.underline]#chain# chain loopWhile chain loopEnd build stem:[\rightarrowtail]

C [.underline]#chain# loopWhile chain loopEnd build stem:[\rightarrowtail]

{empty} [.underline]#C C# loopWhile chain loopEnd build stem:[\rightarrowtail]

C loopWhile [.underline]#chain# loopEnd build stem:[\rightarrowtail]

C [.underline]#loopWhile C loopEnd# build stem:[\rightarrowtail]

{empty} [.underline]#C W build# stem:[\rightarrowtail] S
====

It looks like every valid string has a forced handle, so the grammar may be deterministic.
To be sure, the grammar should be _DK-tested_.

*TODO* DK-test






